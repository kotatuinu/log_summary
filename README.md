# ログ集計Perlプログラム（ひな形）
 ログを集計するのにPerlはかなり強力なツールになるのです。  
 でも、いちいち新たに書き起こすのは面倒なわけで。  
 というわけで、ある程度、形にしたものをひな形を作ってみました。  
 これは、Apacheログから、IPをキーに時系列に並べるものにしてみました。  
  
 大体のログの集計は、以下の工程を経ると思われ。  
1. ログファイルを読み込む  
2. 必要な部分を切り出す  
3. 特定の情報をキーにして集計する  
  
 必要に応じて書き換えてくださいな。  
 知識としてperlの正規表現とか必要ですが。  
  
 例えば、以下のApacheログに対して正規表現で抽出してみると。  

 10.2.3.4 - - [18/Apr/2005:00:10:47 +0900] "GET / HTTP/1.1" 200 854 "-" "Mozilla/4.0 (compatible; MSIE 5.5; Windows 98)"  
  ↓  
 /^((\d{1,3}\.){3}\d{1,3}) .+ \[(\d{2}\/.+\/\d{4}:\d{2}:\d{2}:\d{2}) .*\] .+/  

 上記の正規表現にヒットした行に対して、パーレン"()"で括られた箇所が抽出されるので、$1 → IPアドレスをキーとして、$3 → 日時を切り出してソート対象とする。  
 あとはログ全体を保持する。  
 データの保持は、データクラスに放り込む形。  
  
 にしても、perlの配列、連想配列は、わけ分からん・・・。  
 配列に連想配列を入れるときは、連想配列を$変数1に格納したものを、()で初期化した$変数2に対してpush()してうまくいったみたいだけど・・・。pushでいれる配列は@$変数2に入れる。(以下の例では、クラスなので{}で括ってあるけど)   
 取り出すときも、$変数を渡して、渡した先では@{}で括ったものを@変数に格納して配列として扱う。そして、連想配列として扱う・・・。  
 試行錯誤してみてできたけれど、やっぱり、わけ分からん。  
  
 ↓logRecord.pm  
_________________________
package logRecord;  
  
sub new {  
	my $pkg = shift;  
	bless {  
		log_data =&gt; (),  
	}, $pkg;  
}  
  
sub add_log {  
	my $self = shift;  
	my ($time, $log) = @_;  
	my $logdata = { 'time' =&gt; $time, 'log' =&gt; $log };  
	push( @{$self-&gt;{log_data}}, $logdata);  
}  
  
sub get_loglist {  
	my $self = shift;  
  
 return $self-&gt;{log_data};  
}  
  
1;  
_________________________

_________________________
 #!/usr/bin/perl  
  
use Time::Piece;  
  
my $log_record = new logRecord;  
$log_record-&gt;add_log("2014/03/23 20:47:00", "test");  
  
my @loglist = @{$log_record-&gt;get_loglist()};  
foreach my $log (sort { $a-&gt;{time} cmp $b-&gt;{time} } @loglist) {  
  
print "$log-&gt;{time}	$log-&gt;{log}\n";  
}  
_________________________


